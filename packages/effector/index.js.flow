//@flow strict

//prettier-ignore
export type kind =
  | 'store'
  | 'event'
  | 'effect'
declare export var Kind: {|
  /*::+*/ store: 'store',
  /*::+*/ event: 'event',
  /*::+*/ effect: 'effect',
|}
export type Subscriber<A> = {next(value: A): void, ...}

export type Subscription = {
  (): void,
  unsubscribe(): void,
  ...
}
export interface Unit<T> {
  /*::+*/ kind: kind;
}
declare export class ComputedEvent<Payload> implements Unit<Payload> {
  /*::+*/ kind: kind;
  watch(watcher: (payload: Payload) => any): Subscription;
  map<T>(fn: (_: Payload) => T): ComputedEvent<T>;
  filter<T>(fn: (_: Payload) => T | void): ComputedEvent<T>;
  prepend<Before>(fn: (_: Before) => Payload): Event<Before>;
  subscribe(subscriber: Subscriber<Payload>): Subscription;
  getType(): string;
}
declare export class Event<Payload> implements Unit<Payload> {
  (payload: Payload): Payload;
  /*::+*/ kind: kind;
  watch(watcher: (payload: Payload) => any): Subscription;
  map<T>(fn: (_: Payload) => T): ComputedEvent<T>;
  filter<T>(fn: (_: Payload) => T | void): ComputedEvent<T>;
  prepend<Before>(fn: (_: Before) => Payload): Event<Before>;
  subscribe(subscriber: Subscriber<Payload>): Subscription;
  getType(): string;
}
export type EventLike<T> = ComputedEvent<T> | Event<T>

declare export class Future<Params, Done, Fail> extends Promise<Done> {
  /*::+*/ args: Params;
  anyway(): Promise<void>;
  cache(): Done | void;
}

declare export class Effect<Params, Done, Fail = Error>
  implements Unit<Params> {
  (payload: Params): Future<Params, Done, Fail>;
  /*::+*/ kind: kind;
  /*::+*/ done: ComputedEvent<{|
    params: Params,
    result: Done,
  |}>;
  /*::+*/ fail: ComputedEvent<{|
    params: Params,
    error: Fail,
  |}>;
  /*::+*/ use: {|
    (asyncFunction: (params: Params) => Promise<Done> | Done): this,
    getCurrent(): (params: Params) => Promise<Done>,
  |};
  watch(watcher: (payload: Params) => any): Subscription;
  prepend<Before>(fn: (_: Before) => Params): Event<Before>;
  //map<T>(fn: (_: E) => T): Event<T>,
  subscribe(subscriber: Subscriber<Params>): Subscription;
  getType(): string;
}

declare export class ComputedStore<State> implements Unit<State> {
  /*::+*/ kind: kind;
  getState(): State;
  map<T>(fn: (_: State, lastState?: T) => T, _: void): ComputedStore<T>;
  map<T>(fn: (_: State, lastState: T) => T, firstState: T): ComputedStore<T>;
  subscribe(listener: any): Subscription;
  watch<E>(
    watcher: (state: State, payload: E, type: string) => any,
    __: void,
  ): Subscription;
  watch<E>(
    trigger: Unit<E>,
    watcher: (state: State, payload: E, type: string) => any,
  ): Subscription;
  thru<U>(fn: (store: this) => U): U;
  shortName: string;
  defaultState: State;
}

declare export class Store<State> implements Unit<State> {
  /*::+*/ kind: kind;
  getState(): State;
  map<T>(fn: (_: State, lastState?: T) => T, _: void): ComputedStore<T>;
  map<T>(fn: (_: State, lastState: T) => T, firstState: T): ComputedStore<T>;
  reset(trigger: Unit<any>): this;
  on<E>(
    trigger: Unit<E>,
    handler: (state: State, payload: E) => State | void,
  ): this;
  off(trigger: Unit<any>): void;
  subscribe(listener: any): Subscription;
  watch<E>(
    watcher: (state: State, payload: E, type: string) => any,
    __: void,
  ): Subscription;
  watch<E>(
    trigger: Unit<E>,
    watcher: (state: State, payload: E, type: string) => any,
  ): Subscription;
  thru<U>(fn: (store: this) => U): U;
  shortName: string;
  defaultState: State;
}
export type StoreLike<T> = ComputedStore<T> | Store<T>

declare export class Domain {
  onCreateEvent(hook: (newEvent: Event<mixed>) => any): Subscription;
  onCreateEffect(
    hook: (newEffect: Effect<mixed, mixed, mixed>) => any,
  ): Subscription;
  onCreateStore(hook: (newStore: Store<mixed>) => any): Subscription;
  onCreateDomain(hook: (newDomain: Domain) => any): Subscription;
  event<Payload>(name?: string): Event<Payload>;
  effect<Params, Done, Fail>(
    name?: string,
    config?: {handler?: (params: Params) => Promise<Done> | Done, ...},
  ): Effect<Params, Done, Fail>;
  domain(name?: string): Domain;
  store<State>(defaultState: State): Store<State>;
  getType(): string;
}

declare export function forward<T>(opts: {|
  /*::+*/ from: Unit<T>,
  /*::+*/ to: Unit<T>,
|}): Subscription
declare export function relayShape<
  E,
  O: {/*::+*/ [field: string]: Unit<any>, ...},
  F: $ObjMap<O, <T>(_: Unit<T>) => T>,
>(opts: {|
  /*::+*/ from: Unit<E>,
  /*::+*/ shape: O,
  query(data: E): $Shape<F>,
|}): Subscription
declare export function relay<T, Arg>(
  from: Unit<T>,
  query: (
    data: T,
  ) => {|
    /*::+*/ arg: Arg,
    /*::+*/ list: Array<?Unit<Arg>>,
  |},
): Subscription
declare export function relay<T, Arg>(opts: {|
  /*::+*/ from: Unit<T>,
  query(
    data: T,
  ): {|
    /*::+*/ arg: Arg,
    /*::+*/ list: Array<?Unit<Arg>>,
  |},
|}): Subscription

declare export function createEvent<Payload>(eventName?: string): Event<Payload>

declare export function createEffect<Params, Done, Fail>(
  effectName?: string,
  config?: {handler?: (params: Params) => Promise<Done> | Done, ...},
): Effect<Params, Done, Fail>

declare export function createStore<State>(defaultState: State): Store<State>
declare export function setStoreName<State>(
  store: StoreLike<State>,
  name: string,
): void

declare export function createStoreObject<
  State: {+[key: string]: StoreLike<any> | any, ...},
>(
  obj: State,
): ComputedStore<
  $ObjMap<
    State,
    //prettier-ignore
    <S>(field: Store<S> | S) => S,
  >,
>
declare export function extract<
  State: {+[key: string]: StoreLike<any> | any, ...},
  NextState: {+[key: string]: StoreLike<any> | any, ...},
>(
  store: StoreLike<State>,
  extractor: (_: State) => NextState,
): ComputedStore<
  $ObjMap<
    NextState,
    //prettier-ignore
    <S>(field: StoreLike<S> | S) => S,
  >,
>
declare export function createApi<
  S,
  Api: {[name: string]: (store: S, e: any) => S, ...},
>(
  store: Store<S>,
  api: Api,
): $ObjMap<Api, <E>(h: (store: S, e: E) => S) => Event<E>>
declare export function restoreObject<
  State: {+[key: string]: StoreLike<any> | any, ...},
>(
  state: State,
): $ObjMap<
  State,
  //prettier-ignore
  & (<S>(field: Store<S> | S) => Store<S>)
  & (<S>(field: ComputedStore<S>) => ComputedStore<S>),
>

declare export function restoreEffect<Done>(
  effect: Effect<any, Done, any>,
  defaultState: Done,
): ComputedStore<Done>

declare export function restoreEvent<Payload>(
  event: EventLike<Payload>,
  defaultState: Payload,
): ComputedStore<Payload>

declare export function restore<Done>(
  effect: Effect<any, Done, any>,
  defaultState: Done,
): ComputedStore<Done>
declare export function restore<Payload>(event: EventLike<Payload>, defaultState: Payload): ComputedStore<Payload>
declare export function restore<State: {+[key: string]: StoreLike<any> | any, ...}>(
  state: State,
): $ObjMap<
  State,
  //prettier-ignore
  & (<S>(field: Store<S> | S) => Store<S>)
  & (<S>(field: ComputedStore<S>) => ComputedStore<S>),
>
declare export function createDomain(domainName?: string): Domain
declare export function combine<R>(fn: () => R): ComputedStore<R>
declare export function combine<A, R>(a: Store<A>, fn: (a: A) => R): ComputedStore<R>
declare export function combine<A, B, R>(
  a: StoreLike<A>,
  b: StoreLike<B>,
  fn: (a: A, b: B) => R,
): ComputedStore<R>
declare export function combine<A, B, C, R>(
  a: StoreLike<A>,
  b: StoreLike<B>,
  c: StoreLike<C>,
  fn: (a: A, b: B, c: C) => R,
): ComputedStore<R>
declare export function combine<A, B, C, D, R>(
  a: StoreLike<A>,
  b: StoreLike<B>,
  c: StoreLike<C>,
  d: StoreLike<D>,
  fn: (a: A, b: B, c: C, d: D) => R,
): ComputedStore<R>
declare export function combine<A, B, C, D, E, R>(
  a: StoreLike<A>,
  b: StoreLike<B>,
  c: StoreLike<C>,
  d: StoreLike<D>,
  e: StoreLike<E>,
  fn: (a: A, b: B, c: C, d: D, e: E) => R,
): ComputedStore<R>
declare export function combine<A, B, C, D, E, F, R>(
  a: StoreLike<A>,
  b: StoreLike<B>,
  c: StoreLike<C>,
  d: StoreLike<D>,
  e: StoreLike<E>,
  f: StoreLike<F>,
  fn: (a: A, b: B, c: C, d: D, e: E, f: F) => R,
): ComputedStore<R>
declare export function combine<A, B, C, D, E, F, G, R>(
  a: StoreLike<A>,
  b: StoreLike<B>,
  c: StoreLike<C>,
  d: StoreLike<D>,
  e: StoreLike<E>,
  f: StoreLike<F>,
  g: StoreLike<G>,
  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G) => R,
): ComputedStore<R>
declare export function combine<A, B, C, D, E, F, G, H, R>(
  a: StoreLike<A>,
  b: StoreLike<B>,
  c: StoreLike<C>,
  d: StoreLike<D>,
  e: StoreLike<E>,
  f: StoreLike<F>,
  g: StoreLike<G>,
  h: StoreLike<H>,
  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H) => R,
): ComputedStore<R>
declare export function combine<A, B, C, D, E, F, G, H, I, R>(
  a: StoreLike<A>,
  b: StoreLike<B>,
  c: StoreLike<C>,
  d: StoreLike<D>,
  e: StoreLike<E>,
  f: StoreLike<F>,
  g: StoreLike<G>,
  h: StoreLike<H>,
  i: StoreLike<I>,
  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I) => R,
): ComputedStore<R>
declare export function combine<A, B, C, D, E, F, G, H, I, J, R>(
  a: StoreLike<A>,
  b: StoreLike<B>,
  c: StoreLike<C>,
  d: StoreLike<D>,
  e: StoreLike<E>,
  f: StoreLike<F>,
  g: StoreLike<G>,
  h: StoreLike<H>,
  i: StoreLike<I>,
  j: StoreLike<J>,
  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J) => R,
): ComputedStore<R>
declare export function combine<A, B, C, D, E, F, G, H, I, J, K, R>(
  a: StoreLike<A>,
  b: StoreLike<B>,
  c: StoreLike<C>,
  d: StoreLike<D>,
  e: StoreLike<E>,
  f: StoreLike<F>,
  g: StoreLike<G>,
  h: StoreLike<H>,
  i: StoreLike<I>,
  j: StoreLike<J>,
  k: StoreLike<K>,
  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K) => R,
): ComputedStore<R>
